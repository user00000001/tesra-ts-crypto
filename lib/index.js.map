{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"crypto\"","webpack:///external \"long\"","webpack:///external \"big-integer\"","webpack:///external \"elliptic\"","webpack:///external \"js-sha3\"","webpack:///external \"bytebuffer\"","webpack:///external \"bs58\"","webpack:///external \"bip39-lite\"","webpack:///external \"hdkey-secp256r1\"","webpack:///external \"scrypt-async\"","webpack:///./src/crypto/curveLabel.ts","webpack:///./src/crypto/consts.ts","webpack:///./src/crypto/signatureScheme.ts","webpack:///./src/crypto/keyType.ts","webpack:///./src/crypto/key.ts","webpack:///./src/utils/reader.ts","webpack:///./src/utils/writer.ts","webpack:///./src/crypto/publicKey.ts","webpack:///./src/crypto/signature.ts","webpack:///./src/crypto/privateKey.ts","webpack:///./src/utils/hash.ts","webpack:///./src/utils/serialize.ts","webpack:///./src/utils/opCode.ts","webpack:///./src/utils/program.ts","webpack:///./src/crypto/address.ts","webpack:///./src/wallet/scrypt.ts","webpack:///./src/wallet/account.ts","webpack:///./src/wallet/identity.ts","webpack:///./src/wallet/wallet.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","CurveLabel","label","hex","preset","this","values","push","item","find","v","undefined","Error","SECP224R1","SECP256R1","SECP384R1","SECP521R1","ED25519","DEFAULT_ALGORITHM","curve","SignatureScheme","labelJWS","ECDSAwithSHA224","ECDSAwithSHA256","ECDSAwithSHA384","ECDSAwithSHA512","ECDSAwithSHA3_224","ECDSAwithSHA3_256","ECDSAwithSHA3_384","ECDSAwithSHA3_512","ECDSAwithRIPEMD160","EDDSAwithSHA512","KeyType","defaultSchema","ECDSA","EDDSA","algorithm","parameters","Buffer","fromLabel","msg","scheme","hash","update","digest","arrayBuffer","schema","obj","b","reader","readUint8","count","readBytes","toBuffer","readUint16","readUint32","readUint64","readInt16","readInt32","readInt64","offset","limit","whence","oldOffset","max","readVarUInt","toNumber","fb","readByte","readUInt16","readUInt32","readUInt64","gt","maxlen","readVarBytes","toString","writer","mark","flip","buffer","reset","lt","writeUint8","lte","writeUint16","writeUint32","writeUint64","writeVarUint","length","writeBytes","writeVarBytes","append","val","pk","algorithmHex","curveHex","fromHex","a","ec","paKey","keyFromPublic","pbKey","pa","getPublic","pb","getX","getY","Number","w","getBytes","signature","isSchemaSupported","getSignContent","computeHash","verifySignature","verifyEcDSASignature","verifyEdDSASignature","slice","verify","data","sigScheme","position","keyType","sk","getEcDSAPublicKey","getEdDSAPublicKey","signed","computeSignature","computeEcDSASignature","computeEdDSASignature","sign","canonical","pers","concat","toArrayLike","R","S","keyFromPrivate","keyFromSecret","sha256","sh","md160","bigIntToBytes","bs","toArray","isZero","isNegative","add","reverse","bigIntFromBytes","ba","bytes","Array","from","subarray","negate","PUSH0","PUSHF","PUSHBYTES1","PUSHBYTES75","PUSHDATA1","PUSHDATA2","PUSHDATA4","PUSHM1","PUSH1","PUSHT","PUSH2","PUSH3","PUSH4","PUSH5","PUSH6","PUSH7","PUSH8","PUSH9","PUSH10","PUSH11","PUSH12","PUSH13","PUSH14","PUSH15","PUSH16","NOP","JMP","JMPIF","JMPIFNOT","CALL","RET","APPCALL","SYSCALL","TAILCALL","DUPFROMALTSTACK","TOALTSTACK","FROMALTSTACK","XDROP","XSWAP","XTUCK","DEPTH","DROP","DUP","NIP","OVER","PICK","ROLL","ROT","SWAP","TUCK","CAT","SUBSTR","LEFT","RIGHT","SIZE","INVERT","AND","OR","XOR","EQUAL","INC","DEC","SIGN","NEGATE","ABS","NOT","NZ","ADD","SUB","MUL","DIV","MOD","SHL","SHR","BOOLAND","BOOLOR","NUMEQUAL","NUMNOTEQUAL","LT","GT","LTE","GTE","MIN","MAX","WITHIN","SHA1","SHA256","HASH160","HASH256","CHECKSIG","VERIFY","CHECKMULTISIG","ARRAYSIZE","PACK","UNPACK","PICKITEM","SETITEM","NEWARRAY","NEWSTRUCT","NEWMAP","APPEND","REVERSE","REMOVE","HASKEY","KEYS","VALUES","THROW","THROWIFNOT","pushBytes","serialize","opCode","num","eq","writeOpCode","param","programFromPubKey","pushPubKey","getProgram","programFromMultiPubKeys","keys","sort","compare","pushNum","forEach","programFromParams","sigs","e","code","prog","fromVmCode","encoded","decoded","hexDecoded","address","toBase58","other","equals","copy","checksum","datas","DEFAULT_SCRYPT","N","keyLength","decryptWithGcm","encrypted","salt","keyphrase","scryptParams","scryptOptions","result","ciphertext","authTag","derived","scryptSync","normalize","derived1","iv","aad","decipher","setAAD","setAuthTag","decrypted","final","err","encryptWithGcm","privateKey","cipher","getAuthTag","params","dkLen","password","scrypt","account","lock","isDefault","publicKey","getPublicKey","fromPubKey","encryptedKey","mnemonic","trim","seed","pri","fromMasterSeed","derive","JSON","parse","deserializeJson","fromBase58","extra","stringify","serializeJson","controls","identity","controlData","id","tstid","toTstId","map","control","deserializeControlsJson","serializeControlsJson","addr","wallet","accounts","identities","createTime","Date","toISOString","version","defaultTstid","defaultAccountAddress","ac","constructAddress","filter"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","module.exports = require(\"crypto\");","module.exports = require(\"long\");","module.exports = require(\"big-integer\");","module.exports = require(\"elliptic\");","module.exports = require(\"js-sha3\");","module.exports = require(\"bytebuffer\");","module.exports = require(\"bs58\");","module.exports = require(\"bip39-lite\");","module.exports = require(\"hdkey-secp256r1\");","module.exports = require(\"scrypt-async\");","/*\n * Copyright (C) 2019-2020 The TesraSupernet Authors\n * This file is part of The TesraSupernet library.\n *\n * The TesraSupernet is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The TesraSupernet is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with The TesraSupernet.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Elliptic curve used.\n */\nexport class CurveLabel {\n  static values: CurveLabel[] = [];\n\n  static SECP224R1 = new CurveLabel('P-224', 1, 'p224');\n  static SECP256R1 = new CurveLabel('P-256', 2, 'p256');\n  static SECP384R1 = new CurveLabel('P-384', 3, 'p384');\n  static SECP521R1 = new CurveLabel('P-521', 4, 'p521');\n  static ED25519 = new CurveLabel('ed25519', 25, 'ed25519');\n\n  /**\n   * Finds Curvecorresponding to specified hex representation.\n   *\n   * @param hex Byte hex value\n   */\n  static fromHex(hex: number): CurveLabel {\n    const item = CurveLabel.values.find((v) => v.hex === hex);\n    if (item === undefined) {\n      throw new Error('Enum value not found');\n    }\n\n    return item;\n  }\n\n  /**\n   * Finds Curve corresponding to specified label representation.\n   *\n   * @param label Label\n   */\n  static fromLabel(label: string): CurveLabel {\n    const item = CurveLabel.values.find((v) => v.label === label);\n    if (item === undefined) {\n      throw new Error('Enum value not found');\n    }\n\n    return item;\n  }\n\n  label: string;\n  hex: number;\n  preset: string;\n\n  constructor(label: string, hex: number, preset: string) {\n    this.label = label;\n    this.hex = hex;\n    this.preset = preset;\n\n    CurveLabel.values.push(this);\n  }\n}\n","export const DEFAULT_ALGORITHM = {\n  algorithm: 'ECDSA',\n  parameters: {\n    curve: 'P-256' // also called secp256r1\n  }\n};\n\nexport const ADDR_LEN = 20;\n","/*\n * Copyright (C) 2019-2020 The TesraSupernet Authors\n * This file is part of The TesraSupernet library.\n *\n * The TesraSupernet is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The TesraSupernet is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with The TesraSupernet.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// tslint:disable:variable-name\n\n/**\n * Schema used during signing and verification of signature.\n */\nexport class SignatureScheme {\n  static values: SignatureScheme[] = [];\n\n  static ECDSAwithSHA224 = new SignatureScheme('SHA224withECDSA', 0, 'ES224');\n  static ECDSAwithSHA256 = new SignatureScheme('SHA256withECDSA', 1, 'ES256');\n  static ECDSAwithSHA384 = new SignatureScheme('SHA384withECDSA', 2, 'ES384');\n  static ECDSAwithSHA512 = new SignatureScheme('SHA512withECDSA', 3, 'ES512');\n  static ECDSAwithSHA3_224 = new SignatureScheme('SHA3-224withECDSA', 4, 'ES3-224');\n  static ECDSAwithSHA3_256 = new SignatureScheme('SHA3-256withECDSA', 5, 'ES3-256');\n  static ECDSAwithSHA3_384 = new SignatureScheme('SHA3-384withECDSA', 6, 'ES3-384');\n  static ECDSAwithSHA3_512 = new SignatureScheme('SHA3-512withECDSA', 7, 'ES3-512');\n  static ECDSAwithRIPEMD160 = new SignatureScheme('RIPEMD160withECDSA', 8, 'ER160');\n  static EDDSAwithSHA512 = new SignatureScheme('SHA512withEdDSA', 10, 'EDS512');\n\n  /**\n   * Finds Signature schema corresponding to specified hex representation.\n   *\n   * @param hex Byte hex value\n   */\n  static fromHex(hex: number): SignatureScheme {\n    const item = SignatureScheme.values.find((v) => v.hex === hex);\n    if (item === undefined) {\n      throw new Error('Enum value not found');\n    }\n\n    return item;\n  }\n\n  /**\n   * Finds Signature schema corresponding to specified label representation.\n   *\n   * @param label Label\n   */\n  static fromLabel(label: string): SignatureScheme {\n    const item = SignatureScheme.values.find((v) => v.label === label);\n    if (item === undefined) {\n      throw new Error('Enum value not found');\n    }\n\n    return item;\n  }\n\n  /**\n   * Finds Signature schema corresponding to specified label representation in JWS.\n   *\n   * @param label Label\n   */\n  static fromLabelJWS(label: string): SignatureScheme {\n    const item = SignatureScheme.values.find((v) => v.labelJWS === label);\n    if (item === undefined) {\n      throw new Error('Enum value not found');\n    }\n\n    return item;\n  }\n\n  label: string;\n  hex: number;\n  labelJWS: string;\n\n  constructor(label: string, hex: number, labelJWS: string) {\n    this.label = label;\n    this.hex = hex;\n    this.labelJWS = labelJWS;\n\n    SignatureScheme.values.push(this);\n  }\n}\n","/*\n * Copyright (C) 2019-2020 The TesraSupernet Authors\n * This file is part of The TesraSupernet library.\n *\n * The TesraSupernet is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The TesraSupernet is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with The TesraSupernet.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { SignatureScheme } from './signatureScheme';\n\n/**\n * Type of key. ECDSA is the default one to use.\n */\nexport class KeyType {\n  static values: KeyType[] = [];\n\n  static ECDSA = new KeyType('ECDSA', 0x12, SignatureScheme.ECDSAwithSHA256);\n  static EDDSA = new KeyType('EDDSA', 0x14, SignatureScheme.EDDSAwithSHA512);\n\n  /**\n   * Finds Key type corresponding to specified hex representation.\n   *\n   * @param hex Byte hex value\n   */\n  static fromHex(hex: number): KeyType {\n    const item = KeyType.values.find((v) => v.hex === hex);\n    if (item === undefined) {\n      throw new Error('Enum value not found');\n    }\n\n    return item;\n  }\n\n  /**\n   * Finds Key type corresponding to specified label representation.\n   *\n   * @param label Label\n   */\n  static fromLabel(label: string): KeyType {\n    const item = KeyType.values.find((v) => v.label === label);\n    if (item === undefined) {\n      throw new Error('Enum value not found');\n    }\n\n    return item;\n  }\n\n  label: string;\n  hex: number;\n  defaultSchema: SignatureScheme;\n\n  constructor(label: string, hex: number, defaultSchema: SignatureScheme) {\n    this.label = label;\n    this.hex = hex;\n    this.defaultSchema = defaultSchema;\n\n    KeyType.values.push(this);\n  }\n}\n","/*\n * Copyright (C) 2019-2020 The TesraSupernet Authors\n * This file is part of The TesraSupernet library.\n *\n * The TesraSupernet is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The TesraSupernet is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with The TesraSupernet.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { createHash } from 'crypto';\nimport { sha3_224, sha3_256, sha3_384, sha3_512 } from 'js-sha3';\nimport { DEFAULT_ALGORITHM } from './consts';\nimport { CurveLabel } from './curveLabel';\nimport { KeyType } from './keyType';\nimport { SignatureScheme } from './signatureScheme';\n\n/**\n * Common representation of private or public key\n */\nexport class Key {\n  /**\n   * Algorithm used for key generation.\n   */\n  algorithm: KeyType;\n\n  /**\n   * Parameters of the algorithm.\n   */\n  parameters: KeyParameters;\n\n  /**\n   * Key data.\n   */\n  key: Buffer;\n\n  /**\n   * Creates Key.\n   *\n   * If no algorithm or parameters are specified, default values will be used.\n   * This is strongly discurraged, because it will forbid using other Key types.\n   * Therefore use it only for testing.\n   *\n   * @param key Hex encoded key value\n   * @param algorithm Key type\n   * @param parameters Parameters of the key type\n   */\n  constructor(key: Buffer | string, algorithm?: KeyType, parameters?: KeyParameters) {\n    if (typeof key === 'string') {\n      key = new Buffer(key, 'hex');\n    }\n\n    this.key = key;\n\n    if (algorithm === undefined) {\n      algorithm = KeyType.fromLabel(DEFAULT_ALGORITHM.algorithm);\n    }\n\n    if (parameters === undefined) {\n      parameters = new KeyParameters(CurveLabel.fromLabel(DEFAULT_ALGORITHM.parameters.curve));\n    }\n\n    this.algorithm = algorithm;\n    this.parameters = parameters;\n  }\n\n  /**\n   * Computes hash of message using hashing function of signature schema.\n   *\n   * @param msg input data\n   * @param scheme Signing schema to use\n   */\n  computeHash(msg: Buffer, scheme: SignatureScheme): Buffer {\n    if (scheme === SignatureScheme.ECDSAwithSHA224) {\n      const hash = createHash('sha224');\n      hash.update(msg);\n      return hash.digest();\n    } else if (scheme === SignatureScheme.ECDSAwithSHA256) {\n      const hash = createHash('sha256');\n      hash.update(msg);\n      return hash.digest();\n    } else if (scheme === SignatureScheme.ECDSAwithSHA384) {\n      const hash = createHash('sha384');\n      hash.update(msg);\n      return hash.digest();\n    } else if (scheme === SignatureScheme.ECDSAwithSHA3_512 || scheme === SignatureScheme.EDDSAwithSHA512) {\n      const hash = createHash('sha512');\n      hash.update(msg);\n      return hash.digest();\n    } else if (scheme === SignatureScheme.ECDSAwithRIPEMD160) {\n      const hash = createHash('ripemd160');\n      hash.update(msg);\n      return hash.digest();\n    } else if (scheme === SignatureScheme.ECDSAwithSHA3_224) {\n      return new Buffer(sha3_224.arrayBuffer(msg));\n    } else if (scheme === SignatureScheme.ECDSAwithSHA3_256) {\n      return new Buffer(sha3_256.arrayBuffer(msg));\n    } else if (scheme === SignatureScheme.ECDSAwithSHA3_384) {\n      return new Buffer(sha3_384.arrayBuffer(msg));\n    } else if (scheme === SignatureScheme.ECDSAwithSHA3_512) {\n      return new Buffer(sha3_512.arrayBuffer(msg));\n    } else {\n      throw new Error('Unsupported hash algorithm.');\n    }\n  }\n\n  /**\n   * Tests if signing schema is compatible with key type.\n   *\n   * @param schema Signing schema to use\n   */\n  isSchemaSupported(schema: SignatureScheme): boolean {\n    switch (schema) {\n      case SignatureScheme.ECDSAwithSHA224:\n      case SignatureScheme.ECDSAwithSHA256:\n      case SignatureScheme.ECDSAwithSHA384:\n      case SignatureScheme.ECDSAwithSHA512:\n      case SignatureScheme.ECDSAwithSHA3_224:\n      case SignatureScheme.ECDSAwithSHA3_256:\n      case SignatureScheme.ECDSAwithSHA3_384:\n      case SignatureScheme.ECDSAwithSHA3_512:\n      case SignatureScheme.ECDSAwithRIPEMD160:\n        return this.algorithm === KeyType.ECDSA;\n      case SignatureScheme.EDDSAwithSHA512:\n        return this.algorithm === KeyType.EDDSA;\n      default:\n        throw new Error('Unsupported signature schema.');\n    }\n  }\n}\n\nexport class KeyParameters {\n  static deserializeJson(obj: any) {\n    return new KeyParameters(CurveLabel.fromLabel(obj.curve));\n  }\n\n  curve: CurveLabel;\n\n  constructor(curve: CurveLabel) {\n    this.curve = curve;\n  }\n\n  serializeJson() {\n    return {\n      curve: this.curve.label\n    };\n  }\n}\n","import * as ByteBuffer from 'bytebuffer';\nimport * as Long from 'long';\n\nexport type Whence = 'start' | 'relative';\n\nexport class Reader {\n  reader: ByteBuffer;\n\n  constructor(b: Buffer) {\n    this.reader = ByteBuffer.wrap(b, 'utf-8', true);\n  }\n\n  readByte(): number {\n    return this.reader.readUint8();\n  }\n\n  readBytes(count: number): Buffer {\n    return new Buffer(this.reader.readBytes(count).toBuffer());\n  }\n\n  readUInt16(): number {\n    return this.reader.readUint16();\n  }\n\n  readUInt32(): number {\n    return this.reader.readUint32();\n  }\n\n  readUInt64(): Long {\n    return this.reader.readUint64();\n  }\n\n  readInt16(): number {\n    return this.reader.readInt16();\n  }\n\n  readInt32(): number {\n    return this.reader.readInt32();\n  }\n\n  readInt64(): Long {\n    return this.reader.readInt64();\n  }\n\n  position(): number {\n    return this.reader.offset;\n  }\n\n  length(): number {\n    return this.reader.limit;\n  }\n\n  seek(offset: number, whence: Whence): number {\n    if (whence === 'start') {\n      const oldOffset = this.reader.offset;\n      this.reader.offset = offset;\n      return oldOffset;\n    } else if (whence === 'relative') {\n      const oldOffset = this.reader.offset;\n      this.reader.offset = oldOffset + offset;\n      return oldOffset;\n    } else {\n      throw new Error('Unsupported Whence');\n    }\n  }\n\n  readVarBytes(max?: number): Buffer {\n    const n = this.readVarUInt(max !== undefined ? Long.fromNumber(max) : undefined).toNumber();\n    return this.readBytes(n);\n  }\n\n  readVarInt(max?: Long): Long {\n    const fb = this.readByte();\n    let value: Long;\n\n    switch (fb) {\n      case 0xfd:\n        value = Long.fromNumber(this.readUInt16());\n        break;\n      case 0xfe:\n        value = Long.fromNumber(this.readUInt32());\n        break;\n      case 0xff:\n        value = this.readUInt64();\n        break;\n      default:\n        value = Long.fromNumber(fb);\n    }\n    if (max !== undefined && value.gt(max)) {\n      return Long.ZERO;\n    }\n    return value;\n  }\n\n  readVarUInt(max?: Long): Long {\n    const fb = this.readByte();\n    let value: Long;\n\n    switch (fb) {\n      case 0xfd:\n        value = Long.fromNumber(this.readInt16());\n        break;\n      case 0xfe:\n        value = Long.fromNumber(this.readInt32());\n        break;\n      case 0xff:\n        value = this.readInt64();\n        break;\n\n      default:\n        value = Long.fromNumber(fb);\n    }\n    if (max !== undefined && value.gt(max)) {\n      return Long.ZERO;\n    }\n    return value;\n  }\n\n  readVarString(maxlen?: number): string {\n    const bs = this.readVarBytes(maxlen);\n    return bs.toString('utf-8');\n  }\n}\n","import * as ByteBuffer from 'bytebuffer';\nimport * as Long from 'long';\n\nexport class Writer {\n  private writer: ByteBuffer;\n\n  constructor() {\n    this.writer = new ByteBuffer(undefined, true, true);\n  }\n\n  getBytes() {\n    this.writer.mark();\n    this.writer.flip();\n    const buffer = new Buffer(this.writer.toBuffer());\n    this.writer.reset();\n    return buffer;\n  }\n\n  writeVarUint(value: Long | number) {\n    if (typeof value === 'number') {\n      value = Long.fromNumber(value);\n    }\n\n    if (value.lt(0xfd)) {\n      this.writer.writeUint8(value.toNumber());\n    } else if (value.lte(0xffff)) {\n      this.writer.writeUint8(0xfd);\n      this.writer.writeUint16(value.toNumber());\n    } else if (value.lte(0xffffffff)) {\n      this.writer.writeUint8(0xfe);\n      this.writer.writeUint32(value.toNumber());\n    } else {\n      this.writer.writeUint8(0xff);\n      this.writer.writeUint64(value);\n    }\n  }\n  writeVarBytes(value: Buffer) {\n    this.writeVarUint(value.length);\n    this.writeBytes(value);\n  }\n  writeString(value: string) {\n    return this.writeVarBytes(new Buffer(value, 'utf-8'));\n  }\n  writeBytes(value: Buffer) {\n    this.writer.append(value);\n  }\n  writeUint8(val: number) {\n    this.writer.writeUint8(val);\n  }\n  writeUint16(val: number) {\n    this.writer.writeUint16(val);\n  }\n  writeUint32(val: number) {\n    this.writer.writeUint32(val);\n  }\n  writeUint64(val: Long) {\n    this.writer.writeUint64(val);\n  }\n}\n\n/**\n * TODO: might implement\n */\nexport class LimitedWriter extends Writer {\n  limit: number;\n\n  constructor(limit: number) {\n    super();\n    this.limit = limit;\n  }\n}\n","import * as elliptic from 'elliptic';\nimport { Reader } from '../utils/reader';\nimport { Writer } from '../utils/writer';\nimport { CurveLabel } from './curveLabel';\nimport { Key, KeyParameters } from './key';\nimport { KeyType } from './keyType';\nimport { Signable } from './signable';\nimport { Signature } from './signature';\nimport { SignatureScheme } from './signatureScheme';\n\nexport class PublicKey extends Key {\n  /**\n   * Deserializes PublicKey\n   *\n   * @param b Buffer\n   *\n   */\n  static deserialize(b: Buffer): PublicKey {\n    const r = new Reader(b);\n\n    if (b.length === 33) {\n      // ECDSA\n      const algorithm = KeyType.ECDSA;\n      const curve = CurveLabel.SECP256R1;\n      const pk = r.readBytes(33);\n      return new PublicKey(pk, algorithm, new KeyParameters(curve));\n    } else {\n      const algorithmHex = r.readByte();\n      const curveHex = r.readByte();\n      const pk = r.readBytes(r.length() - 2);\n\n      return new PublicKey(pk, KeyType.fromHex(algorithmHex), new KeyParameters(CurveLabel.fromHex(curveHex)));\n    }\n  }\n\n  static compare(a: PublicKey, b: PublicKey) {\n    if (a.algorithm !== b.algorithm) {\n      return a.algorithm.hex - b.algorithm.hex;\n    }\n\n    switch (a.algorithm) {\n      case KeyType.ECDSA:\n        const ec = new elliptic.ec(a.parameters.curve.preset);\n        const paKey = ec.keyFromPublic(a.key, 'hex');\n        const pbKey = ec.keyFromPublic(b.key, 'hex');\n        const pa = paKey.getPublic();\n        const pb = pbKey.getPublic();\n        if (pa.getX() !== pb.getX()) {\n          return pa.getX() - pb.getX();\n        } else {\n          return pa.getY() - pb.getY();\n        }\n      case KeyType.EDDSA:\n        return Number(a.key.toString('hex')) - Number(b.key.toString('hex'));\n      default:\n        return 0;\n    }\n  }\n\n  serialize(): Buffer {\n    const w = new Writer();\n\n    switch (this.algorithm) {\n      case KeyType.ECDSA:\n        w.writeBytes(this.key);\n        break;\n      case KeyType.EDDSA:\n        w.writeUint8(this.algorithm.hex);\n        w.writeUint8(this.parameters.curve.hex);\n        w.writeBytes(this.key);\n        break;\n    }\n    return w.getBytes();\n  }\n\n  /**\n   * Verifies if the signature was created with private key corresponding to supplied public key\n   * and was not tampered with using signature schema.\n   *\n   * @param msg Buffer input data or Signable object\n   * @param signature Signature object\n   */\n  async verify(msg: Buffer | Signable, signature: Signature): Promise<boolean> {\n    if (!this.isSchemaSupported(signature.algorithm)) {\n      throw new Error('Signature schema does not match key type.');\n    }\n\n    // retrieves content to sign if not provided directly\n    if (!(msg instanceof Buffer)) {\n      msg = msg.getSignContent();\n    }\n\n    const hash = this.computeHash(msg, signature.algorithm);\n\n    return this.verifySignature(hash, signature.value, signature.algorithm);\n  }\n\n  /**\n   * For internal use.\n   * @param hash Message hash\n   * @param signature Hex encoded signature\n   * @param schema Signature scheme to use\n   */\n  verifySignature(hash: Buffer, signature: Buffer, schema: SignatureScheme): boolean {\n    switch (schema) {\n      case SignatureScheme.ECDSAwithSHA224:\n      case SignatureScheme.ECDSAwithSHA256:\n      case SignatureScheme.ECDSAwithSHA384:\n      case SignatureScheme.ECDSAwithSHA512:\n      case SignatureScheme.ECDSAwithSHA3_224:\n      case SignatureScheme.ECDSAwithSHA3_256:\n      case SignatureScheme.ECDSAwithSHA3_384:\n      case SignatureScheme.ECDSAwithSHA3_512:\n      case SignatureScheme.ECDSAwithRIPEMD160:\n        return this.verifyEcDSASignature(hash, signature);\n      case SignatureScheme.EDDSAwithSHA512:\n        return this.verifyEdDSASignature(hash, signature);\n      default:\n        throw new Error('Unsupported signature schema.');\n    }\n  }\n\n  /**\n   * Verifies EcDSA signature of message hash. Curve name is derrived from private key.\n   *\n   * @param hash Message hash\n   * @param signature Hex encoded signature\n   */\n  verifyEcDSASignature(hash: Buffer, signature: Buffer): boolean {\n    const r: any = signature.slice(0, 32);\n    const s: any = signature.slice(32, 64);\n\n    const ec = new elliptic.ec(this.parameters.curve.preset);\n    return ec.verify(hash, { r, s }, this.key, 'hex');\n  }\n\n  /**\n   * Verifies EdDSA signature of message hash. Curve name is derrived from private key.\n   *\n   * @param hash Message hash\n   * @param signature Hex encoded signature\n   */\n  verifyEdDSASignature(hash: Buffer, signature: Buffer): boolean {\n    const r = signature.slice(0, 64);\n    const s = signature.slice(64, 64);\n\n    const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n    return eddsa.verify(hash, { r, s }, this.key, 'hex');\n  }\n}\n","/*\n * Copyright (C) 2019-2020 The TesraSupernet Authors\n * This file is part of The TesraSupernet library.\n *\n * The TesraSupernet is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The TesraSupernet is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with The TesraSupernet.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { Reader } from '../utils/reader';\nimport { Writer } from '../utils/writer';\nimport { SignatureScheme } from './signatureScheme';\n\n/**\n * Signature generated by signing data with Private Key.\n */\nexport class Signature {\n  /**\n   * Deserializes Signature\n   * @param data\n   */\n  static deserialize(data: Buffer): Signature {\n    if (data.length < 2) {\n      throw new Error('Invalid params.');\n    }\n\n    if (data.length === 64) {\n      const sigScheme = SignatureScheme.ECDSAwithSHA256;\n      return new Signature(sigScheme, data);\n    } else {\n      const r = new Reader(data);\n      const scheme = r.readByte();\n      const sigScheme = SignatureScheme.fromHex(scheme);\n      const value = r.readBytes(r.length() - r.position());\n      return new Signature(sigScheme, value);\n    }\n  }\n\n  algorithm: SignatureScheme;\n  value: Buffer;\n\n  constructor(algorithm: SignatureScheme, value: Buffer) {\n    this.algorithm = algorithm;\n    this.value = value;\n  }\n\n  /**\n   * Serializes signature to Hex representation.\n   * For transfer to java backend and verify it.\n   */\n  serialize(): Buffer {\n    const w = new Writer();\n    w.writeUint8(this.algorithm.hex);\n    w.writeBytes(this.value);\n    return w.getBytes();\n  }\n}\n","import { randomBytes } from 'crypto';\nimport * as elliptic from 'elliptic';\nimport { Reader } from '../utils/reader';\nimport { CurveLabel } from './curveLabel';\nimport { Key, KeyParameters } from './key';\nimport { KeyType } from './keyType';\nimport { PublicKey } from './publicKey';\nimport { Signable } from './signable';\nimport { Signature } from './signature';\nimport { SignatureScheme } from './signatureScheme';\n\nexport class PrivateKey extends Key {\n  /**\n   * Generates random Private key using supplied Key type and parameters.\n   *\n   * If no Key type or parameters is supplied, default SDK key type with default parameters will be used.\n   *\n   * @param keyType The key type\n   * @param parameters The parameters for the key type\n   */\n  static random(keyType?: KeyType, parameters?: KeyParameters): PrivateKey {\n    if (keyType === undefined) {\n      keyType = KeyType.ECDSA;\n    }\n\n    if (parameters === undefined) {\n      parameters = new KeyParameters(CurveLabel.SECP256R1);\n    }\n\n    return new PrivateKey(randomBytes(32), keyType, parameters);\n  }\n  static deserialize(b: Buffer): PrivateKey {\n    const r = new Reader(b);\n\n    if (b.length === 32) {\n      // ECDSA\n      const algorithm = KeyType.ECDSA;\n      const curve = CurveLabel.SECP256R1;\n      const sk = r.readBytes(32);\n      return new PrivateKey(sk, algorithm, new KeyParameters(curve));\n    } else {\n      const algorithmHex = r.readByte();\n      const curveHex = r.readByte();\n      const sk = r.readBytes(32);\n\n      return new PrivateKey(sk, KeyType.fromHex(algorithmHex), new KeyParameters(CurveLabel.fromHex(curveHex)));\n    }\n  }\n\n  /**\n   * Derives Public key out of Private key.\n   */\n  getPublicKey(): PublicKey {\n    switch (this.algorithm) {\n      case KeyType.ECDSA:\n        return this.getEcDSAPublicKey();\n      case KeyType.EDDSA:\n        return this.getEdDSAPublicKey();\n      default:\n        throw new Error('Unsupported signature schema.');\n    }\n  }\n\n  /**\n   * Signs the data with supplied private key using signature schema.\n   *\n   * If the signature schema is not provided, the default schema for this key type is used.\n   *\n   * This method is not suitable, if external keys (Ledger, TPM, ...) support is required.\n   *\n   * @param msg Hex encoded input data or Signable object\n   * @param schema Signing schema to use\n   * @param publicKeyId Id of public key\n   */\n  async sign(msg: Buffer | Signable, schema?: SignatureScheme): Promise<Signature> {\n    if (schema === undefined) {\n      schema = this.algorithm.defaultSchema;\n    }\n\n    if (!this.isSchemaSupported(schema)) {\n      throw new Error('Signature schema does not match key type.');\n    }\n\n    // retrieves content to sign if not provided directly\n    if (!(msg instanceof Buffer)) {\n      msg = msg.getSignContent();\n    }\n\n    const hash = this.computeHash(msg, schema);\n\n    const signed = this.computeSignature(hash, schema);\n    return new Signature(schema, signed);\n  }\n\n  /**\n   * Computes signature of message hash using specified signature schema.\n   *\n   * @param hash Message hash\n   * @param schema Signature schema to use\n   */\n  private computeSignature(hash: Buffer, schema: SignatureScheme): Buffer {\n    switch (schema) {\n      case SignatureScheme.ECDSAwithSHA224:\n      case SignatureScheme.ECDSAwithSHA256:\n      case SignatureScheme.ECDSAwithSHA384:\n      case SignatureScheme.ECDSAwithSHA512:\n      case SignatureScheme.ECDSAwithSHA3_224:\n      case SignatureScheme.ECDSAwithSHA3_256:\n      case SignatureScheme.ECDSAwithSHA3_384:\n      case SignatureScheme.ECDSAwithSHA3_512:\n      case SignatureScheme.ECDSAwithRIPEMD160:\n        return this.computeEcDSASignature(hash);\n      case SignatureScheme.EDDSAwithSHA512:\n        return this.computeEdDSASignature(hash);\n      default:\n        throw new Error('Unsupported signature schema.');\n    }\n  }\n\n  /**\n   * Computes EcDSA signature of message hash. Curve name is derrived from private key.\n   *\n   * @param hash Message hash\n   */\n  private computeEcDSASignature(hash: Buffer): Buffer {\n    const ec = new elliptic.ec(this.parameters.curve.preset);\n    const signed = ec.sign(hash, this.key, { canonical: true, pers: undefined });\n    return Buffer.concat([signed.r.toArrayLike(Buffer, 'be', 32), signed.s.toArrayLike(Buffer, 'be', 32)]);\n  }\n\n  /**\n   * Computes EdDSA signature of message hash. Curve name is derrived from private key.\n   *\n   * @param hash Message hash\n   */\n  private computeEdDSASignature(hash: Buffer): Buffer {\n    const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n    // const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n    const signed = eddsa.sign(hash, this.key, null);\n    return Buffer.concat([signed.R.toArrayLike(Buffer, 'be', 32), signed.S.toArrayLike(Buffer, 'be', 32)]);\n  }\n\n  /**\n   * Derives Public key out of Private key using EcDSA algorithm.\n   */\n  private getEcDSAPublicKey(): PublicKey {\n    const ec = new elliptic.ec(this.parameters.curve.preset);\n    const keyPair = ec.keyFromPrivate(this.key, 'hex');\n    const pk = keyPair.getPublic(true, 'hex');\n\n    return new PublicKey(pk, this.algorithm, this.parameters);\n  }\n\n  /**\n   * Derives Public key out of Private key using EdDSA algorithm.\n   */\n  private getEdDSAPublicKey(): PublicKey {\n    const eddsa = new elliptic.eddsa(this.parameters.curve.preset);\n    const keyPair = eddsa.keyFromSecret(this.key, 'hex');\n    const pk = keyPair.getPublic(true, 'hex');\n\n    return new PublicKey(pk, this.algorithm, this.parameters);\n  }\n}\n","import { createHash } from 'crypto';\n\nexport function sha256(data: Buffer) {\n  const sh = createHash('sha256');\n  sh.update(data);\n  return sh.digest();\n}\n\nexport function md160(data: Buffer) {\n  const sh = createHash('ripemd160');\n  sh.update(data);\n  return sh.digest();\n}\n","import * as bigInt from 'big-integer';\n\n// tslint:disable:no-bitwise\n\nexport function bigIntToBytes(data: bigInt.BigInteger) {\n  let bs = data.toArray(256).value;\n\n  if (data.isZero()) {\n    return new Buffer('');\n  }\n\n  const b = bs[0];\n\n  if (data.isNegative()) {\n    for (let i = 0; i < bs.length; i++) {\n      bs[i] = 255 ^ bs[i];\n    }\n\n    const temp = bigInt.fromArray(bs, 256);\n    const temp2 = temp.add(bigInt.one);\n    bs = temp2.toArray(256).value;\n\n    bs = bs.reverse();\n\n    if (b >> 7 === 1) {\n      bs = bs.concat(255);\n    }\n  } else {\n    bs = bs.reverse();\n    if (b >> 7 === 1) {\n      bs = bs.concat(0);\n    }\n  }\n\n  return new Buffer(bs);\n}\n\nexport function bigIntFromBytes(ba: Buffer): bigInt.BigInteger {\n  const l = ba.length;\n  if (l === 0) {\n    return bigInt.zero;\n  }\n\n  let bytes = Array.from(ba.subarray(0));\n  bytes = bytes.reverse();\n\n  if (bytes[0] >> 7 === 1) {\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = 255 ^ bytes[i];\n    }\n\n    const temp = bigInt.fromArray(bytes, 256);\n    const temp2 = temp.add(bigInt(1));\n    bytes = temp2.toArray(256).value;\n    return bigInt.fromArray(bytes, 256).negate();\n  }\n\n  return bigInt.fromArray(bytes, 256);\n}\n","export type OpCode = number;\n\nexport const PUSH0 = 0x00; // An empty array of bytes is pushed onto the stack.\nexport const PUSHF = PUSH0;\nexport const PUSHBYTES1 = 0x01; // 0x01-0x4B The next bytes is data to be pushed onto the stack\nexport const PUSHBYTES75 = 0x4b;\nexport const PUSHDATA1 = 0x4c; // The next byte contains the number of bytes to be pushed onto the stack.\nexport const PUSHDATA2 = 0x4d; // The next two bytes contain the number of bytes to be pushed onto the stack.\nexport const PUSHDATA4 = 0x4e; // The next four bytes contain the number of bytes to be pushed onto the stack.\nexport const PUSHM1 = 0x4f; // The number -1 is pushed onto the stack.\nexport const PUSH1 = 0x51; // The number 1 is pushed onto the stack.\nexport const PUSHT = PUSH1;\nexport const PUSH2 = 0x52; // The number 2 is pushed onto the stack.\nexport const PUSH3 = 0x53; // The number 3 is pushed onto the stack.\nexport const PUSH4 = 0x54; // The number 4 is pushed onto the stack.\nexport const PUSH5 = 0x55; // The number 5 is pushed onto the stack.\nexport const PUSH6 = 0x56; // The number 6 is pushed onto the stack.\nexport const PUSH7 = 0x57; // The number 7 is pushed onto the stack.\nexport const PUSH8 = 0x58; // The number 8 is pushed onto the stack.\nexport const PUSH9 = 0x59; // The number 9 is pushed onto the stack.\nexport const PUSH10 = 0x5a; // The number 10 is pushed onto the stack.\nexport const PUSH11 = 0x5b; // The number 11 is pushed onto the stack.\nexport const PUSH12 = 0x5c; // The number 12 is pushed onto the stack.\nexport const PUSH13 = 0x5d; // The number 13 is pushed onto the stack.\nexport const PUSH14 = 0x5e; // The number 14 is pushed onto the stack.\nexport const PUSH15 = 0x5f; // The number 15 is pushed onto the stack.\nexport const PUSH16 = 0x60; // The number 16 is pushed onto the stack.\n// Flow control\nexport const NOP = 0x61; // Does nothing.\nexport const JMP = 0x62;\nexport const JMPIF = 0x63;\nexport const JMPIFNOT = 0x64;\nexport const CALL = 0x65;\nexport const RET = 0x66;\nexport const APPCALL = 0x67;\nexport const SYSCALL = 0x68;\nexport const TAILCALL = 0x69;\nexport const DUPFROMALTSTACK = 0x6a;\n// Stack\nexport const TOALTSTACK = 0x6b; // Puts the input onto the top of the alt stack. Removes it from the main stack.\nexport const FROMALTSTACK = 0x6c; // Puts the input onto the top of the main stack. Removes it from the alt stack.\nexport const XDROP = 0x6d;\nexport const XSWAP = 0x72;\nexport const XTUCK = 0x73;\nexport const DEPTH = 0x74; // Puts the number of stack items onto the stack.\nexport const DROP = 0x75; // Removes the top stack item.\nexport const DUP = 0x76; // Duplicates the top stack item.\nexport const NIP = 0x77; // Removes the second-to-top stack item.\nexport const OVER = 0x78; // Copies the second-to-top stack item to the top.\nexport const PICK = 0x79; // The item n back in the stack is copied to the top.\nexport const ROLL = 0x7a; // The item n back in the stack is moved to the top.\nexport const ROT = 0x7b; // The top three items on the stack are rotated to the left.\nexport const SWAP = 0x7c; // The top two items on the stack are swapped.\nexport const TUCK = 0x7d; // The item at the top of the stack is copied and inserted before the second-to-top item.\n// Splice\nexport const CAT = 0x7e; // Concatenates two strings.\nexport const SUBSTR = 0x7f; // Returns a section of a string.\nexport const LEFT = 0x80; // Keeps only characters left of the specified point in a string.\nexport const RIGHT = 0x81; // Keeps only characters right of the specified point in a string.\nexport const SIZE = 0x82; // Returns the length of the input string.\n// Bitwise logic\nexport const INVERT = 0x83; // Flips all of the bits in the input.\nexport const AND = 0x84; // Boolean and between each bit in the inputs.\nexport const OR = 0x85; // Boolean or between each bit in the inputs.\nexport const XOR = 0x86; // Boolean exclusive or between each bit in the inputs.\nexport const EQUAL = 0x87; // Returns 1 if the inputs are exactly equal, 0 otherwise.\n// export const EQUALVERIFY = 0x88; // Same as EQUAL, but runs VERIFY afterward.\n// export const RESERVED1 = 0x89; // Transaction is invalid unless occuring in an unexecuted IF branch\n// export const RESERVED2 = 0x8A; // Transaction is invalid unless occuring in an unexecuted IF branch\n\n// Arithmetic\n// Note: Arithmetic inputs are limited to signed 32-bit integers, but may overflow their output.\nexport const INC = 0x8b; // 1 is added to the input.\nexport const DEC = 0x8c; // 1 is subtracted from the input.\nexport const SIGN = 0x8d;\n// export const SAL           = 0x8D; // The input is multiplied by 2.\n// export const SAR           = 0x8E; // The input is divided by 2.\nexport const NEGATE = 0x8f; // The sign of the input is flipped.\nexport const ABS = 0x90; // The input is made positive.\nexport const NOT = 0x91; // If the input is 0 or 1, it is flipped. Otherwise the output will be 0.\nexport const NZ = 0x92; // Returns 0 if the input is 0. 1 otherwise.\nexport const ADD = 0x93; // a is added to b.\nexport const SUB = 0x94; // b is subtracted from a.\nexport const MUL = 0x95; // a is multiplied by b.\nexport const DIV = 0x96; // a is divided by b.\nexport const MOD = 0x97; // Returns the remainder after dividing a by b.\nexport const SHL = 0x98; // Shifts a left b bits, preserving sign.\nexport const SHR = 0x99; // Shifts a right b bits, preserving sign.\nexport const BOOLAND = 0x9a; // If both a and b are not 0, the output is 1. Otherwise 0.\nexport const BOOLOR = 0x9b; // If a or b is not 0, the output is 1. Otherwise 0.\nexport const NUMEQUAL = 0x9c; // Returns 1 if the numbers are equal, 0 otherwise.\nexport const NUMNOTEQUAL = 0x9e; // Returns 1 if the numbers are not equal, 0 otherwise.\nexport const LT = 0x9f; // Returns 1 if a is less than b, 0 otherwise.\nexport const GT = 0xa0; // Returns 1 if a is greater than b, 0 otherwise.\nexport const LTE = 0xa1; // Returns 1 if a is less than or equal to b, 0 otherwise.\nexport const GTE = 0xa2; // Returns 1 if a is greater than or equal to b, 0 otherwise.\nexport const MIN = 0xa3; // Returns the smaller of a and b.\nexport const MAX = 0xa4; // Returns the larger of a and b.\nexport const WITHIN = 0xa5; // Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.\n// Crypto\n// export const RIPEMD160 = 0xA6; // The input is hashed using RIPEMD-160.\nexport const SHA1 = 0xa7; // The input is hashed using SHA-1.\nexport const SHA256 = 0xa8; // The input is hashed using SHA-256.\nexport const HASH160 = 0xa9;\nexport const HASH256 = 0xaa;\n// tslint:disable-next-line:max-line-length\nexport const CHECKSIG = 0xac; // The entire transaction's outputs inputs and script (from the most recently-executed CODESEPARATOR to the end) are hashed. The signature used by CHECKSIG must be a valid signature for this hash and public key. If it is 1 is returned 0 otherwise.\nexport const VERIFY = 0xad;\n// tslint:disable-next-line:max-line-length\nexport const CHECKMULTISIG = 0xae; // For each signature and public key pair CHECKSIG is executed. If more public keys than signatures are listed some key/sig pairs can fail. All signatures need to match a public key. If all signatures are valid 1 is returned 0 otherwise. Due to a bug one extra unused value is removed from the stack.\n// Array\n// tslint:disable:indent\nexport const ARRAYSIZE = 0xc0;\nexport const PACK = 0xc1;\nexport const UNPACK = 0xc2;\nexport const PICKITEM = 0xc3;\nexport const SETITEM = 0xc4;\nexport const NEWARRAY = 0xc5;\nexport const NEWSTRUCT = 0xc6;\nexport const NEWMAP = 0xc7;\nexport const APPEND = 0xc8;\nexport const REVERSE = 0xc9;\nexport const REMOVE = 0xca;\nexport const HASKEY = 0xcb;\nexport const KEYS = 0xcc;\nexport const VALUES = 0xcd;\n// Exception\nexport const THROW = 0xf0;\nexport const THROWIFNOT = 0xf1;\n","import * as bigInt from 'big-integer';\nimport * as Long from 'long';\nimport { PublicKey } from '../crypto/publicKey';\nimport { bigIntToBytes } from '../utils/serialize';\nimport { Writer } from '../utils/writer';\nimport * as O from './opCode';\n\nexport class ProgramBuilder {\n  w: Writer;\n\n  constructor() {\n    this.w = new Writer();\n  }\n\n  pushPubKey(key: PublicKey) {\n    this.pushBytes(key.serialize());\n  }\n\n  writeOpCode(opCode: O.OpCode) {\n    this.w.writeUint8(opCode);\n  }\n\n  writeByte(val: number) {\n    this.w.writeUint8(val);\n  }\n\n  writeBytes(b: Buffer) {\n    this.w.writeBytes(b);\n  }\n\n  writeVarUInt(val: Long) {\n    this.w.writeVarUint(val);\n  }\n\n  pushBytes(data: Buffer) {\n    // pushing empty buffer should not do any damage\n    // if (data.length === 0) {\n    //   throw new Error('push data error: data is nil');\n    // }\n\n    if (data.length <= O.PUSHBYTES75 + 1 - O.PUSHBYTES1) {\n      this.w.writeUint8(data.length + O.PUSHBYTES1 - 1);\n    } else if (data.length < 0x100) {\n      this.w.writeUint8(O.PUSHDATA1);\n      this.w.writeUint8(data.length);\n    } else if (data.length < 0x10000) {\n      this.w.writeUint8(O.PUSHDATA2);\n      this.w.writeUint16(data.length);\n    } else {\n      this.w.writeUint8(O.PUSHDATA4);\n      this.w.writeUint32(data.length);\n    }\n    this.w.writeBytes(data);\n  }\n\n  pushNum(num: number | Long) {\n    if (typeof num === 'number') {\n      num = Long.fromNumber(num);\n    }\n\n    if (num.eq(-1)) {\n      this.writeOpCode(O.PUSHM1);\n    } else if (num.isZero()) {\n      this.writeOpCode(O.PUSH0);\n    } else if (num.gt(0) && num.lt(16)) {\n      this.writeOpCode(num.toNumber() - 1 + O.PUSH1);\n    } else {\n      this.pushBytes(bigIntToBytes(bigInt(num.toString())));\n    }\n  }\n\n  pushBool(param: boolean) {\n    if (param) {\n      this.writeOpCode(O.PUSHT);\n    } else {\n      this.writeOpCode(O.PUSHF);\n    }\n  }\n  getProgram(): Buffer {\n    return this.w.getBytes();\n  }\n}\n\nexport function programFromPubKey(key: PublicKey): Buffer {\n  const b = new ProgramBuilder();\n  b.pushPubKey(key);\n  b.writeOpCode(O.CHECKSIG);\n  return b.getProgram();\n}\n\nexport function programFromMultiPubKeys(m: number, keys: PublicKey[]): Buffer {\n  if (m === 1) {\n    return programFromPubKey(keys[0]);\n  }\n\n  const n = keys.length;\n  if (!(1 <= m && m <= n && n <= 1024)) {\n    throw new Error('Wrong multi-sig param');\n  }\n\n  keys.sort(PublicKey.compare);\n\n  const b = new ProgramBuilder();\n\n  b.pushNum(m);\n\n  keys.forEach((key) => {\n    b.pushPubKey(key);\n  });\n\n  b.pushNum(n);\n\n  b.writeOpCode(O.CHECKMULTISIG);\n  return b.getProgram();\n}\n\nexport function programFromParams(sigs: Buffer[]) {\n  const b = new ProgramBuilder();\n\n  for (const s of sigs) {\n    b.pushBytes(s);\n  }\n\n  return b.getProgram();\n}\n","import * as base58 from 'bs58';\nimport { PublicKey } from '../crypto/publicKey';\nimport { md160, sha256 } from '../utils/hash';\nimport { programFromPubKey } from '../utils/program';\nimport { Reader } from '../utils/reader';\nimport { Writer } from '../utils/writer';\nimport { ADDR_LEN } from './consts';\n\nexport class Address {\n  static deserialize(b: Buffer) {\n    const r = new Reader(b);\n\n    try {\n      const value = r.readBytes(ADDR_LEN);\n      return new Address(value);\n    } catch (e) {\n      throw new Error('deserialize Uint256 error');\n    }\n  }\n\n  static fromVmCode(code: Buffer): Address {\n    return new Address(md160(sha256(code)));\n  }\n\n  static fromPubKey(key: PublicKey): Address {\n    const prog = programFromPubKey(key);\n\n    return Address.fromVmCode(prog);\n  }\n\n  static fromBase58(encoded: string): Address {\n    const decoded = base58.decode(encoded);\n    const hexDecoded = new Buffer(decoded).slice(1, 20 + 1);\n\n    const address = new Address(hexDecoded);\n\n    if (encoded !== address.toBase58()) {\n      throw new Error('[Address.fromBase58] decode encoded verify failed');\n    }\n    return address;\n  }\n\n  private value: Buffer;\n\n  constructor(value: Buffer | string = '0000000000000000000000000000000000000000') {\n    if (typeof value === 'string') {\n      this.value = new Buffer(value, 'hex');\n    } else {\n      this.value = value;\n    }\n  }\n\n  equals(other: Address): boolean {\n    return this.value.equals(other.value);\n  }\n\n  serialize(w: Writer) {\n    w.writeBytes(this.value);\n  }\n\n  toArray() {\n    const buffer = new Buffer(this.value.length);\n    this.value.copy(buffer);\n    return buffer;\n  }\n\n  toBase58(): string {\n    const data = Buffer.concat([new Buffer('17', 'hex'), this.value]);\n    const hash = sha256(data);\n    const hash2 = sha256(hash);\n    const checksum = hash2.slice(0, 4);\n\n    const datas = Buffer.concat([data, checksum]);\n\n    return base58.encode(datas);\n  }\n\n  toTstId() {\n    return 'did:tst:' + this.toBase58();\n  }\n}\n","import { createCipheriv, createDecipheriv, ScryptOptions } from 'crypto';\nimport * as asyncScrypt from 'scrypt-async';\n\nexport interface ScryptOptionsEx extends ScryptOptions {\n  keyLength: number;\n}\n\nexport const DEFAULT_SCRYPT: ScryptOptionsEx = {\n  N: 4096,\n  r: 8,\n  p: 8,\n  keyLength: 64\n};\n\nexport const DEFAULT_SCRYPT_KEYLENGTH = 64;\n\nexport function decryptWithGcm(\n  encrypted: string,\n  address: string,\n  salt: Buffer,\n  keyphrase: string,\n  scryptParams: ScryptOptionsEx\n) {\n  const { keyLength, ...scryptOptions } = scryptParams;\n\n  const result = Buffer.from(encrypted, 'base64');\n  const ciphertext = result.slice(0, result.length - 16);\n  const authTag = result.slice(result.length - 16);\n  const derived = scryptSync(keyphrase.normalize('NFC'), salt, keyLength, scryptOptions);\n  const derived1 = derived.slice(0, 12);\n  const derived2 = derived.slice(32);\n  const key = derived2;\n  const iv = derived1;\n  const aad = new Buffer(address);\n\n  const decipher = createDecipheriv('aes-256-gcm', key, iv);\n  decipher.setAAD(aad);\n  decipher.setAuthTag(authTag);\n  let decrypted = decipher.update(ciphertext).toString('hex');\n\n  try {\n    decrypted += decipher.final().toString('hex');\n  } catch (err) {\n    throw new Error('Password incorrect');\n  }\n  return decrypted;\n}\n\n/**\n * Encrypt with aes-gcm-256\n * This is the default encryption algorithm for private key\n * @param privateKey Private key to encpryt with\n * @param address Adderss to encrypt with\n * @param salt Salt to encrypt with\n * @param keyphrase User's password\n * @param scryptParams Optional params to encrypt\n */\nexport function encryptWithGcm(\n  privateKey: Buffer,\n  address: string,\n  salt: Buffer,\n  keyphrase: string,\n  scryptParams: ScryptOptionsEx\n) {\n  const { keyLength, ...scryptOptions } = scryptParams;\n\n  const derived = scryptSync(keyphrase.normalize('NFC'), salt, keyLength, scryptOptions);\n  const derived1 = derived.slice(0, 12);\n  const derived2 = derived.slice(32);\n  const key = derived2;\n  const iv = derived1;\n  const aad = new Buffer(address);\n  const cipher = createCipheriv('aes-256-gcm', key, iv);\n  cipher.setAAD(aad);\n  let ciphertext = cipher.update(privateKey);\n  // ciphertext += cipher.final();\n  const final = cipher.final();\n  const authTag = cipher.getAuthTag();\n  ciphertext = Buffer.concat([ciphertext, final]);\n\n  const result = Buffer.concat([ciphertext, authTag]);\n  return result.toString('base64');\n}\n\n/**\n * Synchronious call to scrypt-async-js.\n *\n * @param keyphrase Keyphrase to use\n * @param addressHash Hex encoded address\n * @param params Scrypt params\n */\nfunction scryptSync(keyphrase: string, salt: Buffer, keyLength: number, params: ScryptOptions) {\n  let derived: number[] = [];\n\n  const s = Array.from(salt.subarray(0));\n  asyncScrypt(\n    keyphrase.normalize('NFC'),\n    s,\n    {\n      N: params.N,\n      r: params.r!,\n      p: params.p!,\n      dkLen: keyLength\n    },\n    (result: string | number[]) => {\n      derived = result as number[];\n    }\n  );\n  return new Buffer(derived);\n}\n","/*\n * Copyright (C) 2019-2020 The TesraSupernet Authors\n * This file is part of The TesraSupernet library.\n *\n * The TesraSupernet is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The TesraSupernet is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with The TesraSupernet.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { toSeedHex, validateMnemonic } from 'bip39-lite';\nimport { randomBytes } from 'crypto';\nimport { HDKey } from 'hdkey-secp256r1';\nimport { Address } from '../crypto/address';\nimport { KeyParameters } from '../crypto/key';\nimport { KeyType } from '../crypto/keyType';\nimport { PrivateKey } from '../crypto/privateKey';\nimport { PublicKey } from '../crypto/publicKey';\nimport { decryptWithGcm, DEFAULT_SCRYPT, encryptWithGcm, ScryptOptionsEx } from './scrypt';\n\n// tslint:disable:quotemark\n// tslint:disable:object-literal-key-quotes\n\nexport const TST_BIP44_PATH = \"m/44'/1024'/0'/0/0\";\n\nexport class Account {\n  /**\n   * Import account\n   * @param label Account's label\n   * @param encryptedKey Encrypted private key\n   * @param password User's password to decrypt private key\n   * @param address Account's address\n   * @param saltBase64 Salt to decrypt\n   * @param params Params used to decrypt\n   */\n  static import(\n    label: string,\n    privateKey: PrivateKey,\n    password: string,\n    salt: Buffer = randomBytes(16),\n    scrypt: ScryptOptionsEx = DEFAULT_SCRYPT\n  ) {\n    const account = new Account();\n\n    if (!label) {\n      label = randomBytes(4).toString('hex');\n    }\n    account.label = label;\n    account.lock = false;\n    account.isDefault = false;\n    account.salt = salt.toString('base64');\n    account.scrypt = scrypt;\n\n    account.publicKey = privateKey.getPublicKey();\n    account.address = Address.fromPubKey(account.publicKey);\n    account.encryptedKey = encryptWithGcm(privateKey.key, account.address.toBase58(), salt, password, scrypt);\n\n    if (!account.address.equals(account.address)) {\n      throw new Error('Computed address does not match the provided address.');\n    }\n\n    return account;\n  }\n\n  /**\n   * Import account with mnemonic\n   * @param label Account's label\n   * @param mnemonic User's mnemonic\n   * @param password user's password to encrypt the private key\n   * @param params Params used to encrypt the private key.\n   */\n  static importMnemonic(label: string, mnemonic: string, password: string, scrypt: ScryptOptionsEx = DEFAULT_SCRYPT) {\n    mnemonic = mnemonic.trim();\n    if (!validateMnemonic(mnemonic)) {\n      throw new Error('Invalid mnemonics');\n    }\n    const seed = toSeedHex(mnemonic);\n    const hdkey = HDKey.fromMasterSeed(Buffer.from(seed, 'hex'));\n    const pri = hdkey.derive(TST_BIP44_PATH);\n    const key = Buffer.from(pri.privateKey!).toString('hex');\n    const privateKey = new PrivateKey(key);\n    const account = Account.create(label, privateKey, password, scrypt);\n    return account;\n  }\n\n  /**\n   * Creates Account object encrypting specified private key.\n   *\n   * The account does not need to be registered on blockchain.\n   *\n   * @param privateKey Private key associated with the account\n   * @param password Password use to encrypt the private key\n   * @param label Custom label\n   * @param params Optional scrypt params\n   */\n  static create(label: string, privateKey: PrivateKey, password: string, scrypt: ScryptOptionsEx = DEFAULT_SCRYPT) {\n    const account = new Account();\n    const salt = randomBytes(16);\n    const publicKey = privateKey.getPublicKey();\n    const address = Address.fromPubKey(publicKey);\n\n    account.label = label;\n    account.lock = false;\n    account.isDefault = false;\n    account.publicKey = publicKey;\n    account.address = address;\n    account.encryptedKey = encryptWithGcm(privateKey.key, address.toBase58(), salt, password, scrypt);\n    account.salt = salt.toString('base64');\n    account.scrypt = scrypt;\n\n    return account;\n  }\n\n  /**\n   * Deserializes JSON object.\n   *\n   * Object should be real object, not stringified.\n   *\n   * @param obj JSON object or string\n   */\n  static deserializeJson(obj: any, scrypt: ScryptOptionsEx = DEFAULT_SCRYPT): Account {\n    if (typeof obj === 'string') {\n      obj = JSON.parse(obj);\n    }\n\n    const pk = new PublicKey(\n      new Buffer(obj.publicKey, 'hex'),\n      KeyType.fromLabel(obj.algorithm),\n      KeyParameters.deserializeJson(obj.parameters)\n    );\n\n    const account = new Account();\n    account.address = Address.fromBase58(obj.address);\n    account.label = obj.label;\n    account.lock = obj.lock;\n    account.isDefault = obj.isDefault;\n    account.publicKey = pk;\n    account.hash = obj.hash;\n    account.salt = obj.salt;\n    account.encryptedKey = obj.key;\n    account.extra = obj.extra;\n    account.scrypt = scrypt;\n    return account;\n  }\n\n  address: Address;\n  label: string;\n  lock: boolean;\n  encryptedKey: string;\n  extra: null;\n\n  // to be compatible with cli wallet\n  'enc-alg': string = 'aes-256-gcm';\n  hash: string = 'sha256';\n  salt: string;\n\n  publicKey: PublicKey;\n  isDefault: boolean;\n\n  scrypt: ScryptOptionsEx;\n\n  /**\n   * Serializes to JSON object.\n   *\n   * Returned object will not be stringified.\n   *\n   */\n  serializeJson(stringify: boolean = false): any {\n    const obj = {\n      address: this.address.toBase58(),\n      label: this.label,\n      lock: this.lock,\n      extra: this.extra,\n      key: this.encryptedKey,\n      'enc-alg': this['enc-alg'],\n      hash: this.hash,\n      salt: this.salt,\n      isDefault: this.isDefault,\n      publicKey: this.publicKey.serialize().toString('hex'),\n      algorithm: this.publicKey.algorithm.label,\n      parameters: this.publicKey.parameters.serializeJson()\n    };\n\n    if (stringify) {\n      return JSON.stringify(obj);\n    } else {\n      return obj;\n    }\n  }\n\n  decryptKey(password: string): PrivateKey | Promise<PrivateKey> {\n    const salt = Buffer.from(this.salt, 'base64');\n    const sk = decryptWithGcm(this.encryptedKey, this.address.toBase58(), salt, password, this.scrypt);\n    return new PrivateKey(sk, this.publicKey.algorithm, this.publicKey.parameters);\n  }\n}\n","import { randomBytes } from 'crypto';\nimport { Address } from '../crypto/address';\nimport { KeyParameters } from '../crypto/key';\nimport { KeyType } from '../crypto/keyType';\nimport { PrivateKey } from '../crypto/privateKey';\nimport { PublicKey } from '../crypto/publicKey';\nimport { decryptWithGcm, DEFAULT_SCRYPT, encryptWithGcm, ScryptOptionsEx } from './scrypt';\n\n// tslint:disable:quotemark\n// tslint:disable:object-literal-key-quotes\n\nexport interface ControlData {\n  /**\n   * Id of control data\n   */\n  id: string;\n  /**\n   * Encrypted private key\n   */\n  encryptedKey: string;\n  /**\n   * Address of control data\n   */\n  address: Address;\n\n  'enc-alg': string;\n\n  /**\n   * Salt of control data\n   */\n  salt: string;\n  /**\n   * hash type\n   */\n  hash: string;\n  /**\n   * The public key\n   */\n  publicKey: PublicKey;\n}\n\nexport class Identity {\n  /**\n   * Import identity\n   * @param label Name of identity\n   * @param encryptedPrivateKey Encrypted private key\n   * @param password User's password to decrypt\n   * @param address Address to decrypt\n   * @param saltBase64 Salt to decrypt\n   * @param params Optional params to decrypt\n   */\n  static importIdentity(\n    label: string,\n    privateKey: PrivateKey,\n    password: string,\n    salt: Buffer = randomBytes(16),\n    scrypt: ScryptOptionsEx = DEFAULT_SCRYPT\n  ) {\n    const identity = new Identity();\n\n    if (!label) {\n      label = randomBytes(4).toString('hex');\n    }\n\n    // tstid\n    const publicKey = privateKey.getPublicKey();\n    const address = Address.fromPubKey(publicKey);\n\n    const controlData = {\n      id: '1', // start from 1\n      encryptedKey: encryptWithGcm(privateKey.key, address.toBase58(), salt, password, scrypt),\n      address,\n      salt: salt.toString('base64'),\n      hash: 'sha256',\n      'enc-alg': 'aes-256-gcm',\n      publicKey,\n      scrypt\n    };\n\n    identity.label = label;\n    identity.lock = false;\n    identity.isDefault = false;\n    identity.tstid = Address.fromPubKey(publicKey).toTstId();\n    identity.controls = [controlData];\n    identity.scrypt = scrypt;\n\n    return identity;\n  }\n\n  /**\n   * Creates Identity object encrypting specified private key.\n   *\n   * The identity is not registered on the blockchain. Caller needs to register it.\n   *\n   * @param label Custom label\n   * @param privateKey Private key associated with the identity\n   * @param password Password use to encrypt the private key\n   * @param scrypt Optional scrypt params\n   */\n  static create(label: string, privateKey: PrivateKey, password: string, scrypt: ScryptOptionsEx = DEFAULT_SCRYPT) {\n    const identity = new Identity();\n\n    // tstid\n    const salt = randomBytes(16);\n    const publicKey = privateKey.getPublicKey();\n    const address = Address.fromPubKey(publicKey);\n\n    const controlData = {\n      id: '1', // start from 1\n      encryptedKey: encryptWithGcm(privateKey.key, address.toBase58(), salt, password, scrypt),\n      address,\n      salt: salt.toString('base64'),\n      hash: 'sha256',\n      'enc-alg': 'aes-256-gcm',\n      publicKey\n    };\n\n    identity.label = label;\n    identity.lock = false;\n    identity.isDefault = false;\n    identity.tstid = Address.fromPubKey(publicKey).toTstId();\n    identity.controls = [controlData];\n    identity.scrypt = scrypt;\n\n    return identity;\n  }\n\n  static deserializeControlsJson(obj: any[]): ControlData[] {\n    return obj.map((control) => {\n      const pk = new PublicKey(\n        new Buffer(control.publicKey, 'hex'),\n        KeyType.fromLabel(control.algorithm),\n        KeyParameters.deserializeJson(control.parameters)\n      );\n\n      return {\n        id: control.id,\n        encryptedKey: control.key,\n        address: Address.fromBase58(control.address),\n        salt: control.salt,\n        hash: control.hash,\n        'enc-alg': control['enc-alg'],\n        publicKey: pk\n      };\n    });\n  }\n\n  /**\n   * Deserializes JSON object.\n   *\n   * Object should be real object, not stringified.\n   *\n   * @param obj JSON object or string\n   */\n  static deserializeJson(obj: any, scrypt: ScryptOptionsEx = DEFAULT_SCRYPT) {\n    if (typeof obj === 'string') {\n      obj = JSON.parse(obj);\n    }\n\n    const identity = new Identity();\n    identity.label = obj.label;\n    identity.lock = obj.lock;\n    identity.tstid = obj.tstid;\n    identity.isDefault = obj.isDefault;\n    identity.extra = obj.extra;\n    identity.controls = Identity.deserializeControlsJson(obj.controls);\n    identity.scrypt = scrypt;\n\n    return identity;\n  }\n\n  tstid: string;\n  label: string;\n  lock: boolean;\n  isDefault: boolean;\n  controls: ControlData[] = [];\n  extra: null;\n  scrypt: ScryptOptionsEx;\n\n  serializeControlsJson(stringify: boolean = false): any {\n    const obj = this.controls.map((control) => ({\n      key: control.encryptedKey,\n      id: control.id,\n      address: control.address.toBase58(),\n      salt: control.salt,\n      'enc-alg': (control as any)['enc-alg'],\n      hash: control.hash,\n      publicKey: control.publicKey.serialize().toString('hex'),\n      algorithm: control.publicKey.algorithm.label,\n      parameters: control.publicKey.parameters.serializeJson()\n    }));\n\n    if (stringify) {\n      return JSON.stringify(obj);\n    } else {\n      return obj;\n    }\n  }\n\n  /**\n   * Serializes to JSON object.\n   *\n   * Returned object will not be stringified.\n   *\n   */\n  serializeJson(stringify: boolean = false): any {\n    const obj = {\n      tstid: this.tstid,\n      label: this.label,\n      lock: this.lock,\n      isDefault: this.isDefault,\n      extra: this.extra,\n      controls: this.serializeControlsJson(false)\n    };\n\n    if (stringify) {\n      return JSON.stringify(obj);\n    } else {\n      return obj;\n    }\n  }\n\n  decryptKey(id: string, password: string): PrivateKey | Promise<PrivateKey> {\n    const control = this.controls.find((c) => c.id === id);\n    if (control === undefined) {\n      throw new Error('ControlData not found.');\n    }\n\n    const salt = Buffer.from(control.salt, 'base64');\n    const sk = decryptWithGcm(control.encryptedKey, control.address.toBase58(), salt, password, this.scrypt);\n    return new PrivateKey(sk, control.publicKey.algorithm, control.publicKey.parameters);\n  }\n}\n","import { Address } from '../crypto/address';\nimport { Account } from './account';\nimport { Identity } from './identity';\nimport { DEFAULT_SCRYPT, DEFAULT_SCRYPT_KEYLENGTH, ScryptOptionsEx } from './scrypt';\n\nexport class Wallet {\n  static constructAddress(address: string | Address) {\n    let addr: Address;\n\n    if (typeof address === 'string') {\n      if (address.length === 40) {\n        addr = new Address(address);\n      } else {\n        addr = Address.fromBase58(address);\n      }\n    } else {\n      addr = address;\n    }\n\n    return addr;\n  }\n  static create() {\n    const wallet = new Wallet();\n    wallet.name = name;\n    wallet.accounts = [];\n    wallet.identities = [];\n\n    // createtime\n    wallet.createTime = new Date().toISOString();\n    wallet.version = '1.0';\n    wallet.scrypt = DEFAULT_SCRYPT;\n    wallet.keyLength = DEFAULT_SCRYPT_KEYLENGTH;\n\n    return wallet;\n  }\n\n  static deserializeJson(obj: any) {\n    if (typeof obj === 'string') {\n      obj = JSON.parse(obj);\n    }\n\n    const wallet = new Wallet();\n    wallet.name = obj.name;\n    wallet.defaultTstid = obj.defaultTstid;\n    wallet.defaultAccountAddress = obj.defaultAccountAddress;\n    wallet.createTime = obj.createTime;\n    wallet.version = obj.version;\n    wallet.scrypt = {\n      N: obj.scrypt.n,\n      r: obj.scrypt.r,\n      p: obj.scrypt.p,\n      keyLength: obj.scrypt.dkLen\n    };\n\n    wallet.identities =\n      obj.identities !== undefined\n        ? (obj.identities as any[]).map((i) => Identity.deserializeJson(i, wallet.scrypt))\n        : [];\n    wallet.accounts =\n      obj.accounts !== undefined ? (obj.accounts as any[]).map((a) => Account.deserializeJson(a, wallet.scrypt)) : [];\n    wallet.extra = obj.extra;\n    return wallet;\n  }\n\n  name: string;\n  defaultTstid: string;\n  defaultAccountAddress: string;\n  createTime: string;\n  version: string;\n  scrypt: ScryptOptionsEx;\n  keyLength: number;\n  identities: Identity[];\n  accounts: Account[];\n  extra: null;\n\n  addAccount(account: Account) {\n    for (const ac of this.accounts) {\n      if (ac.address.equals(account.address)) {\n        return;\n      }\n    }\n    this.accounts.push(account);\n  }\n\n  delAccount(address: string | Address) {\n    const addr = Wallet.constructAddress(address);\n\n    this.accounts = this.accounts.filter((account) => !account.address.equals(addr));\n  }\n\n  getAccount(address: string | Address) {\n    const addr = Wallet.constructAddress(address);\n\n    return this.accounts.find((account) => account.address.equals(addr));\n  }\n\n  addIdentity(identity: Identity) {\n    for (const i of this.identities) {\n      if (i.tstid === identity.tstid) {\n        return;\n      }\n    }\n    this.identities.push(identity);\n  }\n\n  delIdentity(tstid: string) {\n    this.identities = this.identities.filter((identity) => !(identity.tstid === tstid));\n  }\n\n  getIdentity(tstid: string) {\n    return this.identities.find((identity) => identity.tstid === tstid);\n  }\n\n  setDefaultAccount(address: string): void {\n    this.defaultAccountAddress = address;\n  }\n\n  setDefaultIdentity(tstid: string): void {\n    this.defaultTstid = tstid;\n  }\n\n  /**\n   * Serializes to JSON object.\n   *\n   *\n   */\n  serializeJson(stringify: boolean = false): any {\n    const obj = {\n      name: this.name,\n      defaultTstid: this.defaultTstid,\n      defaultAccountAddress: this.defaultAccountAddress,\n      createTime: this.createTime,\n      version: this.version,\n      scrypt: {\n        n: this.scrypt.N,\n        r: this.scrypt.r,\n        p: this.scrypt.p,\n        dkLen: this.scrypt.keyLength\n      },\n      identities: this.identities.map((i) => i.serializeJson(false)),\n      accounts: this.accounts.map((a) => a.serializeJson(false)),\n      extra: null\n    };\n\n    if (stringify) {\n      return JSON.stringify(obj);\n    } else {\n      return obj;\n    }\n  }\n}\n","export { CurveLabel } from './crypto/curveLabel';\nexport { Key } from './crypto/key';\nexport { PublicKey } from './crypto/publicKey';\nexport { PrivateKey } from './crypto/privateKey';\nexport { Signature } from './crypto/signature';\nexport { Signable } from './crypto/signable';\nexport { SignatureScheme } from './crypto/signatureScheme';\nexport { KeyType } from './crypto/keyType';\nexport { Address } from './crypto/address';\nexport { Account } from './wallet/account';\nexport { Identity } from './wallet/identity';\nexport { Wallet } from './wallet/wallet';\nexport { ProgramBuilder, programFromMultiPubKeys, programFromParams, programFromPubKey } from './utils/program';\nexport { Reader } from './utils/reader';\nexport { Writer } from './utils/writer';\n\nimport * as OpCode from './utils/opCode';\nexport { OpCode };\n\nimport * as Hash from './utils/hash';\nexport { Hash };\n\nimport * as Serialize from './utils/serialize';\nexport { Serialize };\n"],"sourceRoot":""}